#! /usr/bin/env python
# encoding: utf-8

import platform

import Utils
import Options


# the following two variables are used by the target "waf dist"
VERSION=''
APPNAME=''


# these variables are mandatory ('/' are converted automatically)
top = '.'
out = 'build'

# TODO extensive testing with different configuration (should work with Python >= 2.3)
# TODO optional usage of MSVC compiler
# TODO test loader on win32 with and without -mms-bitfields CCFLAG
# TODO 64bit Windows support
# TODO Mac OS X support


def set_options(opt):
    opt.add_option('--lsb',
            action = 'store_true',
            help = 'Build LSB (Linux Standard Base) boot loader. By default PATH is searched for lsbcc otherwise is tried file /opt/lsb/bin/lsbcc.',
            default = False,
            dest = 'lsb')
    opt.add_option('--lsbcc-path',
            action = 'store',
            help = 'Path to lsbcc [Default: lsbcc]',
            default = 'lsbcc',
            dest = 'lsbcc_path')
    opt.add_option('--lsb-target-version',
            action = 'store',
            help = 'Specify LSB target version [Default: 4.0]',
            default = '4.0',
            dest = 'lsb_version')

    opt.tool_options('compiler_cc')
    opt.tool_options('python')



def configure(conf):

    conf.env.NAME = 'default'
    
    opt = Options.options
    myplatform = Utils.detect_platform()
    Utils.pprint('CYAN', '%s detected' % myplatform)

    if opt.lsb:
        Utils.pprint('CYAN', 'Building LSB boot loader')

    if myplatform.startswith('darwin'):
        conf.env.MACOSX_DEPLOYMENT_TARGET = '10.4'

    ### C compiler
    
    if myplatform.startswith('win'):
        try:
            # mingw (gcc for Windows)
            conf.check_tool('gcc')
        except:
            try:
                # Newest detected MSVC version is used by default.
                # msvc 7.1 (Visual Studio 2003)
                # msvc 8.0 (Visual Studio 2005)
                # msvc 9.0 (Visual Studio 2008)
                #conf.env['MSVC_VERSIONS'] = ['msvc 7.1', 'msvc 8.0', 'msvc 9.0']
                # 32bit architecture
                conf.env['MSVC_TARGETS'] = ['x86', 'ia32']
                conf.check_tool('msvc')
                conf.print_all_msvc_detected()
            except:
                Utils.pprint('RED', 'GCC (MinGW) or MSVC compiler not found.')
                exit(1)
    else:
        conf.check_tool('compiler_cc')


    conf.check_tool('python')
    conf.check_python_headers()

    # Do not link with libpython and libpthread.
    for lib in conf.env.LIB_PYEMBED:
        if lib.startswith('python') or lib.startswith('pthread'):
            conf.env.LIB_PYEMBED.remove(lib)


    ### build LSB (Linux Standard Base) boot loader

    if opt.lsb:
        # custom lsbcc path
        if opt.lsbcc_path != 'lsbcc':
            conf.env.LSBCC = conf.find_program(opt.lsbcc_path, mandatory=True)
        # default values
        else:
            conf.env.LSBCC = conf.find_program(opt.lsbcc_path)
            if not conf.env.LSBCC:
                conf.env.LSBCC = conf.find_program('/opt/lsb/bin/lsbcc',
                        mandatory=True)
        # lsbcc as CC compiler
        conf.env.append_value('CCFLAGS', '--lsb-cc=%s' % conf.env.CC[0])
        conf.env.append_value('LINKFLAGS', '--lsb-cc=%s' % conf.env.CC[0])
        conf.env.CC = conf.env.LSBCC
        conf.env.LINK_CC = conf.env.LSBCC
        ## check LSBCC flags
        # --lsb-besteffort - binary will work on platforms without LSB stuff
        # --lsb-besteffort - available in LSB build tools >= 4.0
        conf.check_cc(ccflags='--lsb-besteffort',
                msg='Checking for LSB build tools >= 4.0',
                errmsg='LSB >= 4.0 is required', mandatory=True)
        conf.env.append_value('CCFLAGS', '--lsb-besteffort')
        conf.env.append_value('LINKFLAGS', '--lsb-besteffort')
        # binary compatibility with a specific LSB version
        # LSB 4.0 can generate binaries compatible with 3.0, 3.1, 3.2, 4.0
        # however because of using function 'mkdtemp', loader requires
        # using target version 4.0
        lsb_target_flag = '--lsb-target-version=%s' % opt.lsb_version
        conf.env.append_value('CCFLAGS', lsb_target_flag)
        conf.env.append_value('LINKFLAGS', lsb_target_flag)


    ### Defines, Includes

    if myplatform.startswith('win'):
        conf.env.append_value('CCDEFINES', 'WIN32')
        conf.env.append_value('CPPPATH', '../zlib')

    conf.env.append_value('CPPPATH', '../common')


    ### Libraries

    if myplatform.startswith('win'):
        conf.check_cc(lib='user32', mandatory=True)
        conf.check_cc(lib='comctl32', mandatory=True)
        conf.check_cc(lib='kernel32', mandatory=True)
        conf.check_cc(lib='ws2_32', mandatory=True)

    else:
        conf.check_cc(lib='z', mandatory=True)

    ### ccflags

    if myplatform.startswith('win') and conf.env.CC_NAME == 'gcc':
        # Disables console - MinGW option
        conf.check_cc(ccflags='-mwindows', mandatory=True,
                msg='Checking for flags -mwindows')
        # Use Visual C++ compatible alignment
        conf.check_cc(ccflags='-mms-bitfields', mandatory=True,
                msg='Checking for flags -mms-bitfields')
        conf.env.append_value('CCFLAGS', '-mms-bitfields')

    # link only with needed libraries
    if conf.check_cc(ccflags='-Wl,--as-needed',
            msg='Checking for flags -Wl,--as-needed'):
        conf.env.append_value('LINKFLAGS', '-Wl,--as-needed')


    ### Other stuff

    if myplatform.startswith('win'):
        # RC file - icon
        conf.check_tool('winres')

    ### DEBUG and RELEASE environments

    rel = conf.env.copy()
    dbg = conf.env.copy()
    rel.set_variant('release') # separate subfolder for building
    dbg.set_variant('debug') # separate subfolder for building
    rel.detach() # detach environment from default
    dbg.detach()

    ## setup DEBUG environment
    dbg.set_variant('debug') # separate subfolder for building
    conf.set_env_name('debug', dbg)
    conf.setenv('debug')
    conf.env.append_value('CCDEFINES', '_DEBUG LAUNCH_DEBUG'.split())
    conf.env.append_value('CCFLAGS', conf.env.CCFLAGS_DEBUG)
    dbgw = conf.env.copy() # WINDOWED DEBUG environment
    dbgw.set_variant('debugw') # separate subfolder for building
    dbgw.detach()
    if myplatform.startswith('win'):
        conf.env.append_value('CCDEFINES', '_CONSOLE')

    ## setup windowed DEBUG environment
    conf.set_env_name('debugw', dbgw)
    conf.setenv('debugw')
    if myplatform.startswith('darwin'):
        conf.env.append_value('CCDEFINES', 'WINDOWED')
    # disables console - MinGW option
    if myplatform.startswith('win') and conf.env.CC_NAME == 'gcc':
        conf.env.append_value('LINKFLAGS', '-mwindows')

    ## setup RELEASE environment
    conf.set_env_name('release', rel)
    conf.setenv('release')
    conf.env.append_value('CCDEFINES', 'NDEBUG')
    conf.env.append_value('CCFLAGS', conf.env.CCFLAGS_RELEASE)
    relw = conf.env.copy() # WINDOWED RELEASE environment
    relw.set_variant('releasew') # separate subfolder for building
    relw.detach()
    if myplatform.startswith('win'):
        conf.env.append_value('CCDEFINES', '_CONSOLE')

    ## setup windowed RELEASE environment
    conf.set_env_name('releasew', relw)
    conf.setenv('releasew')
    if myplatform.startswith('darwin'):
        conf.env.append_value('CCDEFINES', 'WINDOWED')
    # disables console - MinGW option
    if myplatform.startswith('win') and conf.env.CC_NAME == 'gcc':
        conf.env.append_value('LINKFLAGS', '-mwindows')


def build(bld):
    # Force to run with 1 job (no parallel building).
    # There are reported build failures on multicore CPUs
    # with some msvc versions.
    Options.options.jobs = 1

    myplatform = Utils.detect_platform()

    targets = dict(release='run', debug='run_d', releasew='runw', debugw='runw_d')

    if myplatform.startswith('win'):

        # static lib zlib

        for key in targets.keys():
            bld(
                features = 'cc cstaticlib',
                source = bld.path.ant_glob('zlib/*.c'),
                target = 'staticlib_zlib',
                env = bld.env_of_name(key),
            )

        # console

        for key in ('release', 'debug'):
            bld(
                features = 'cc cprogram pyembed',
                source = bld.path.ant_glob('windows/winmain.c windows/run.rc common/*.c'),
                target = targets[key],
                install_path = '../../support/loader', # CWD is the 'build' directory
                uselib_local = 'staticlib_zlib',
                uselib = 'USER32 COMCTL32 KERNEL32 WS2_32',
                env = bld.env_of_name(key).copy(),
            )

        # windowed

        for key in ('releasew', 'debugw'):
            bld(
                features = 'cc cprogram pyembed',
                source = bld.path.ant_glob('windows/winmain.c windows/runw.rc common/*.c'), # uses different RC file (icon)
                target = targets[key],
                install_path = '../../support/loader', # CWD is the 'build' directory
                uselib_local = 'staticlib_zlib',
                uselib = 'USER32 COMCTL32 KERNEL32 WS2_32',
                env = bld.env_of_name(key).copy(),
            )

        ## inprocsrvr

        targets2 = dict(release='inprocsrvr', debug='inprocsrvr_d', releasew='inprocsrvrw', debugw='inprocsrvrw_d')
        for key, value in targets2.items():
            bld_e = bld(
                features = 'cc cshlib',
                source = bld.path.ant_glob('common/launch.c windows/dllmain.c'),
                target = value,
                install_path = '../../support/loader', # CWD is the 'build' directory
                uselib_local = 'staticlib_zlib',
                uselib = 'USER32 COMCTL32 KERNEL32 WS2_32',
                env = bld.env_of_name(key).copy(),
            )


    else: # linux, darwin (MacOSX)

        for key, value in targets.items():
            bld(
                features = 'cc cprogram pyembed',
                source = bld.path.ant_glob('linux/*.c common/*.c'),
                target = value,
                install_path = '../../support/loader', # CWD is the 'build' directory
                uselib = 'Z', # zlib
                env = bld.env_of_name(key).copy(),
            )

