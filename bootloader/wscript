#! /usr/bin/env python
#-----------------------------------------------------------------------------
# Copyright (c) 2014, PyInstaller Development Team.
#
# Distributed under the terms of the GNU General Public License with exception
# for distributing bootloader.
#
# The full license is in the file COPYING.txt, distributed with this software.
#-----------------------------------------------------------------------------


"""
Bootloader building script.
"""


import os
import platform
import sys


# The following two variables are used by the target "waf dist"
VERSION=''
APPNAME=''


# These variables are mandatory ('/' are converted automatically)
top = '.'
out = 'build'


# TODO use following variable only on darwin and for 32bit loader.
# TODO Do we still need this variable on OS X?
# OS X 10.5 doesn't understand the load command  'LC_DYLD_INFO_ONLY'
# that is used by the OS X 10.6 linker.
# The following variable fixes 10.5 compatibility.
os.environ['MACOSX_DEPLOYMENT_TARGET'] = '10.5'


# TODO strip created binaries.


def architecture():
    """
    on 64bit Mac function platform.architecture() returns 64bit even
    for 32bit Python. This is the workaround for this.
    """
    if platform.system() == 'Darwin' and sys.maxsize <= 3**32:
        return '32bit'
    else:
        return platform.architecture()[0] # 32bit or 64bit


def options(ctx):

    ctx.add_option('--debug',
                   action='store_true',
                   help='Include debugging info for GDB.',
                   default=False,
                   dest='debug')

    if platform.system() != ('Windows'):
        ctx.add_option('--leak-detector',
                       action='store_true',
                       help='Link with Boehm garbage collector to detect memory leaks.',
                       default=False,
                       dest='boehmgc')
        # TODO Does waf 1.8 detects clang out of the box?
        ctx.add_option('--clang',
                       action='store_true',
                       help='Try to find clang C compiler instead of gcc.',
                       default=False,
                       dest='clang')

    if platform.system() == 'Linux':
        ctx.add_option('--no-lsb',
                       action='store_true',
                       help='Prevent building LSB (Linux Standard Base) bootloader.',
                       default=False,
                       dest='nolsb')
        ctx.add_option('--lsbcc-path',
                       action='store',
                       help='Path to lsbcc. By default PATH is searched for lsbcc otherwise is tried file /opt/lsb/bin/lsbcc. [Default: lsbcc]',
                       default='lsbcc',
                       dest='lsbcc_path')
        ctx.add_option('--lsb-target-version',
                       action='store',
                       help='Specify LSB target version [Default: 4.0]',
                       default='4.0',
                       dest='lsb_version')

    ctx.load('compiler_c')


def configure(ctx):

    ctx.env.NAME = 'default'

    myplatform = platform.system()

    ctx.env.MYARCH = architecture()

    # Differenciate path to bootloader with machine name if necessary.
    mymach = platform.machine()
    if mymach.startswith('arm'):
        mymach = 'arm'
    else:
        # Assume x86/x86_64 machine.
        mymach = None
    ctx.env.MYMACHINE = mymach


    ctx.msg('Platform', '%s-%s detected' % (platform.system(), architecture()))

    if myplatform == 'Darwin' and architecture() == '64bit':
        ctx.msg('CYAN', 'WARNING: Building bootloader for Python 64-bit on Mac OSX')
        ctx.msg('CYAN', 'For 32b-bit bootloader prepend the python command with:')
        ctx.msg('CYAN', 'VERSIONER_PYTHON_PREFER_32_BIT=yes arch -i386 python')

    if myplatform == 'Linux' and not ctx.options.nolsb:
        ctx.msg('Building LSB bootloader.')

    ### C compiler

    if myplatform == 'Windows':
        try:
            # mingw (gcc for Windows)
            ctx.load('gcc')
        except:
            try:
                # Newest detected MSVC version is used by default.
                # msvc 7.1 (Visual Studio 2003)
                # msvc 8.0 (Visual Studio 2005)
                # msvc 9.0 (Visual Studio 2008)
                ctx.env['MSVC_VERSIONS'] = ['msvc 7.1', 'msvc 8.0', 'msvc 9.0', 'wsdk 7.0', 'wsdk 7.1']
                if architecture() == '32bit':
                    ctx.env['MSVC_TARGETS'] = ['x86', 'ia32']
                elif architecture() == '64bit':
                    ctx.env['MSVC_TARGETS'] = ['x64', 'x86_amd64', 'intel64', 'em64t']
                ctx.load('msvc')
                ctx.print_all_msvc_detected()
                # Do not embed manifest file.
                # Manifest file will be added in the phase of packaging python application.
                ctx.env.MSVC_MANIFEST = False
            except Exception as e:
                print(e)
                ctx.msg('RED', str(e))
                ctx.msg('RED', 'GCC (MinGW) or MSVC compiler not found.')
                exit(1)
        else:
            # When using GCC, deactivate declarations after statements
            # (not supported by Visual Studio)
            ctx.env.append_value('CCFLAGS', '-Wdeclaration-after-statement')
            ctx.env.append_value('CCFLAGS', '-Werror')

    else:
        ctx.load('compiler_c')


    ### build LSB (Linux Standard Base) boot loader
    if myplatform == 'Linux' and not ctx.options.nolsb:
        try:
            # custom lsbcc path
            if ctx.options.lsbcc_path != 'lsbcc':
                ctx.env.LSBCC = ctx.find_program(ctx.options.lsbcc_path, mandatory=True)
            # default values
            else:
                ctx.env.LSBCC = ctx.find_program(ctx.options.lsbcc_path)
                if not ctx.env.LSBCC:
                    ctx.env.LSBCC = ctx.find_program('/opt/lsb/bin/lsbcc',
                            mandatory=True)
        except:
            ctx.msg('RED', 'LSB (Linux Standard Base) tools >= 4.0 are required.')
            ctx.msg('RED', 'Try --no-lsb option if not interested in building LSB binary.')
            exit(2)
        # lsbcc as CC compiler
        ctx.env.append_value('CCFLAGS', '--lsb-cc=%s' % ctx.env.CC[0])
        ctx.env.append_value('LINKFLAGS', '--lsb-cc=%s' % ctx.env.CC[0])
        ctx.env.CC = ctx.env.LSBCC
        ctx.env.LINK_CC = ctx.env.LSBCC
        ## check LSBCC flags
        # --lsb-besteffort - binary will work on platforms without LSB stuff
        # --lsb-besteffort - available in LSB build tools >= 4.0
        ctx.check_cc(ccflags='--lsb-besteffort',
                msg='Checking for LSB build tools >= 4.0',
                errmsg='LSB >= 4.0 is required', mandatory=True)
        ctx.env.append_value('CCFLAGS', '--lsb-besteffort')
        ctx.env.append_value('LINKFLAGS', '--lsb-besteffort')
        # binary compatibility with a specific LSB version
        # LSB 4.0 can generate binaries compatible with 3.0, 3.1, 3.2, 4.0
        # however because of using function 'mkdtemp', loader requires
        # using target version 4.0
        lsb_target_flag = '--lsb-target-version=%s' % ctx.options.lsb_version
        ctx.env.append_value('CCFLAGS', lsb_target_flag)
        ctx.env.append_value('LINKFLAGS', lsb_target_flag)


    ### Clang as CC compiler.
    if not myplatform == 'Windows' and ctx.options.clang:
        ctx.env.CC = ctx.find_program('clang', mandatory=True)
        ctx.env.LINK_CC = ctx.env.CC


    ### Include gcc debugging information for debugging in GDB.
    if ctx.options.debug:
        ctx.env.append_value('CCFLAGS', '-g')


    ### Defines, Includes

    if myplatform == 'Linux':
        # make sure we don't use declarations after statement (break Visual Studio)
        ctx.env.append_value('CCFLAGS', '-Wdeclaration-after-statement')
        ctx.env.append_value('CCFLAGS', '-Werror')

    if not myplatform == 'Windows':
        # Defines common for Unix and Unix-like platforms.
        # For details see:
        #   http://man.he.net/man7/feature_test_macros
        #
        ## Without these definitions compiling maight fail on OSX.
        ctx.env.append_value('CCDEFINES', '_POSIX_C_SOURCE=200112L')
        # SUS v2 (UNIX 98) definitions.
        #   Mac OS X 10.5 is UNIX 03 compliant.
        ctx.env.append_value('CCDEFINES', '_XOPEN_SOURCE=500')
        ctx.env.append_value('CCDEFINES', '_REENTRANT')
        # Function 'mkdtemp' is available only if _BSD_SOURCE is defined.
        ctx.env.append_value('CCDEFINES', '_BSD_SOURCE')
        

    if myplatform == 'Windows':
        ctx.env.append_value('CCDEFINES', 'WIN32')
        ctx.env.append_value('CPPPATH', '../zlib')

    # TODO find out proper value.
    if myplatform == 'Solaris':
        ctx.env.append_value('CCDEFINES', 'SUNOS')

    # TODO find out proper value.
    if myplatform == 'AIX':
        ctx.env.append_value('CCDEFINES', 'AIX')

    ctx.env.append_value('CPPPATH', os.path.join('..', 'common'))


    ### Libraries

    if myplatform == 'Windows':
        ctx.check_cc(lib='user32', mandatory=True)
        ctx.check_cc(lib='comctl32', mandatory=True)
        ctx.check_cc(lib='kernel32', mandatory=True)
        ctx.check_cc(lib='ws2_32', mandatory=True)

    else:
        ctx.check_cc(lib='dl', mandatory=True)
        ctx.check_cc(lib='z', mandatory=True)

        # This uses Boehm GC to manage memory - it replaces malloc() / free()
        # functions. Some messages are printed if memory is not deallocated.
        if ctx.options.boehmgc:
            ctx.check_cc(lib='gc', mandatory=True)
            ctx.env.append_value('CCDEFINES', 'PYI_LEAK_DETECTOR')
            ctx.env.append_value('CCDEFINES', 'GC_FIND_LEAK')
            ctx.env.append_value('CCDEFINES', 'GC_DEBUG')
            ctx.env.append_value('CCDEFINES', 'SAVE_CALL_CHAIN')

    ### ccflags

    if myplatform == 'Windows' and ctx.env.CC_NAME == 'gcc':
        # Disables console - MinGW option
        ctx.check_cc(ccflags='-mwindows', mandatory=True,
                msg='Checking for flags -mwindows')
        # Use Visual C++ compatible alignment
        ctx.check_cc(ccflags='-mms-bitfields', mandatory=True,
                msg='Checking for flags -mms-bitfields')
        ctx.env.append_value('CCFLAGS', '-mms-bitfields')

    elif myplatform == 'Windows' and ctx.env.CC_NAME == 'msvc':
        if architecture() == '32bit':
            ctx.env.append_value('LINKFLAGS', '/MACHINE:X86')
        elif architecture() == '64bit':
            ctx.env.append_value('LINKFLAGS', '/MACHINE:X64')
        # Enable 64bit porting warnings and other warnings too.
        ctx.env.append_value('CCFLAGS', '/W3')
        # We use SEH exceptions in winmain.c; make sure they are activated.
        ctx.env.append_value('CCFLAGS', '/EHa')
    
    # Compile with 64bit gcc 32bit binaries or vice versa.
    if ctx.env.CC_NAME == 'gcc':
        if architecture() == '32bit' and ctx.check_cc(ccflags='-m32', msg='Checking for flags -m32'):
            ctx.env.append_value('CCFLAGS', '-m32')
        elif architecture() == '64bit':
            ctx.env.append_value('CCFLAGS', '-m64')

    # Ensure proper architecture flags on Mac OS X.
    # TODO Add support for universal binaries.
    if myplatform == 'Darwin':

        available_archs = {'32bit': 'i386', '64bit': 'x86_64'}
        mac_arch = available_archs[architecture()]

        ctx.env.append_value('CCFLAGS', '-arch')
        ctx.env.append_value('CCFLAGS', mac_arch)
        ctx.env.append_value('CXXFLAGS', '-arch')
        ctx.env.append_value('CXXFLAGS', mac_arch)
        ctx.env.append_value('LINKFLAGS', '-arch')
        ctx.env.append_value('LINKFLAGS', mac_arch)

        if architecture() == '32bit':
            ctx.env.append_value('CCFLAGS', '-mmacosx-version-min=10.5')
        else:
            ctx.env.append_value('CCFLAGS', '-mmacosx-version-min=10.6')

        

       
    # On linux link only with needed libraries.
    # -Wl,--as-needed is on some platforms detected during configure but
    # fails during build. (Mac OS X, Solaris, AIX)
    if myplatform == 'Linux' and ctx.check_cc(ccflags='-Wl,--as-needed',
            msg='Checking for flags -Wl,--as-needed'):
        ctx.env.append_value('LINKFLAGS', '-Wl,--as-needed')


    ### Other stuff

    if myplatform == 'Windows':
        # RC file - icon
        ctx.load('winres')

    ### DEBUG and RELEASE environments
    basic_env = ctx.get_env()

    ## setup DEBUG environment
    ctx.setenv('debug')
    ctx.set_env(basic_env)  # Ensure environment contains shared values.
    # This define enables verbose console output of the bootloader.
    ctx.env.append_value('CCDEFINES', ['LAUNCH_DEBUG'])
    ctx.env.append_value('CCDEFINES', 'NDEBUG')
    debug_env = ctx.get_env()

    ## setup windowed DEBUG environment
    ctx.setenv('debugw')
    ctx.set_env(debug_env)  # Ensure environment contains shared debug values.
    ctx.env.append_value('CCDEFINES', 'WINDOWED')
    # disables console - mingw option
    if myplatform == 'Windows' and ctx.env.CC_NAME == 'gcc':
            ctx.env.append_value('LINKFLAGS', '-mwindows')
    elif myplatform == 'Darwin':
        #conf.env.append_value('CCFLAGS', '-I/Developer/Headers/FlatCarbon')
        # To support catching AppleEvents and running as ordinary OSX GUI app,
        # we have to link against the Carbon framework.
        # This linkage only needs to be there for the windowed bootloaders.
        ctx.env.append_value('LINKFLAGS', '-framework')
        ctx.env.append_value('LINKFLAGS', 'Carbon')
        # conf.env.append_value('LINKFLAGS', '-framework')
        # conf.env.append_value('LINKFLAGS', 'ApplicationServices')

    ## setup RELEASE environment
    ctx.setenv('release')
    ctx.set_env(basic_env)  # Ensure environment contains shared values.
    ctx.env.append_value('CCDEFINES', 'NDEBUG')
    ctx.env.append_value('CCFLAGS', ctx.env.CCFLAGS_RELEASE)
    release_env = ctx.get_env()

    ## setup windowed RELEASE environment
    ctx.setenv('releasew')
    ctx.set_env(release_env)  # Copy values from release environment.
    ctx.env.append_value('CCDEFINES', 'WINDOWED')
    # disables console
    if myplatform == 'Windows' and ctx.env.CC_NAME == 'gcc':
            ctx.env.append_value('LINKFLAGS', '-mwindows')
    elif myplatform == 'Windows':
        # To support catching AppleEvents and running as ordinary OSX GUI app,
        # we have to link against the Carbon framework.
        # This linkage only needs to be there for the windowed bootloaders.
        ctx.env.append_value('LINKFLAGS', '-framework')
        ctx.env.append_value('LINKFLAGS', 'Carbon')
        # TODO Do we need to link with this framework?
        # conf.env.append_value('LINKFLAGS', '-framework')
        # conf.env.append_value('LINKFLAGS', 'ApplicationServices')


# TODO Use 'strip' command to decrease the size of compiled bootloaders.
def build(ctx):
    myplatform = platform.system()
    opt = ctx.options

    # Force to run with 1 job (no parallel building).
    # There are reported build failures on multicore CPUs
    # with some msvc versions.
    # TODO revisit parallel building with switch to waf 1.7
    opt.jobs = 1

    install_path = '../../PyInstaller/bootloader/' + platform.system() + "-" + ctx.env.MYARCH
    if ctx.env.MYMACHINE:
        install_path += '-' + ctx.env.MYMACHINE
    targets = dict(release='run', debug='run_d', releasew='runw', debugw='runw_d')

    if myplatform == 'Windows':

        # static lib zlib

        for key in targets.keys():
            ctx(
                features = 'cc cstaticlib',
                source = ctx.path.ant_glob('zlib/*.c'),
                target = 'staticlib_zlib',
                env = ctx.env_of_name(key),
                includes = ['zlib'],
            )

        # console

        for key in ('release', 'debug'):
            ctx(
                features = 'cc cprogram',
                source = ctx.path.ant_glob('windows/run.rc common/*.c'),
                target = targets[key],
                install_path = install_path,
                uselib_local = 'staticlib_zlib',
                uselib = 'USER32 COMCTL32 KERNEL32 WS2_32',
                env = ctx.env_of_name(key).copy(),
                includes = ['common', 'windows', 'zlib'],
            )

        # windowed

        for key in ('releasew', 'debugw'):
            ctx(
                features = 'cc cprogram',
                source = ctx.path.ant_glob('windows/runw.rc common/*.c'), # uses different RC file (icon)
                target = targets[key],
                install_path = install_path,
                uselib_local = 'staticlib_zlib',
                uselib = 'USER32 COMCTL32 KERNEL32 WS2_32',
                env = ctx.env_of_name(key).copy(),
                includes = ['common', 'windows', 'zlib'],
            )

    else: # Linux, Darwin (MacOSX), ...

        libs = ['dl', 'z', 'm']  # 'z' - zlib, 'm' - math,
        if opt.boehmgc:
            libs.append('gc')

        for key, value in targets.items():
            ctx(
                features = 'cc cprogram',
                source = ctx.path.ant_glob('linux/*.c common/*.c'),
                target = value,
                install_path = install_path,
                lib = libs,
                env = ctx.env_of_name(key).copy(),
                includes = ['common', 'linux'],
            )
